#!/usr/bin/env python3
"""
recover_from_txt.py

Usage:
  # One hash per line:
  python recover_from_txt.py --input hashes.txt

  # Or lines like "username,hash" or "id,username,hash":
  python recover_from_txt.py --input hashes_with_names.txt

Options:
  --key KEY       DES key (8 chars). Default: "12345678"
  --output FILE   Output text file (default: recovered.txt)
  --sep SEP       If a line contains commas, split by this separator (default: ,)
"""
import argparse
import base64
import binascii
from Crypto.Cipher import DES
from Crypto.Util.Padding import unpad

DEFAULT_KEY = "12345678"

def ensure_key8(key: str) -> bytes:
    b = key.encode('utf-8')
    if len(b) < 8:
        raise ValueError("DES key must be exactly 8 bytes long (8 characters).")
    return b[:8]

def try_decode(ciphertext: str) -> bytes:
    if ciphertext is None:
        return None
    s = str(ciphertext).strip()
    if s == "" or s.upper() == "NULL":
        return None
    # try base64 with auto padding
    try:
        pad_len = (-len(s)) % 4
        s_padded = s + ("=" * pad_len)
        return base64.b64decode(s_padded)
    except Exception:
        # fallback to hex
        try:
            return binascii.unhexlify(s)
        except Exception:
            raise ValueError("Cannot decode ciphertext (not base64 or hex).")

def decrypt_password(encrypted_password: str, key: str) -> str:
    decoded = try_decode(encrypted_password)
    if decoded is None:
        return None
    des = DES.new(ensure_key8(key), DES.MODE_ECB)
    try:
        plaintext = unpad(des.decrypt(decoded), DES.block_size)
    except Exception as e:
        raise ValueError(f"Decryption/padding failed: {e}")
    return plaintext.decode('utf-8', errors='replace')

def parse_plain_lines(path, sep=','):
    rows = []
    with open(path, 'r', encoding='utf-8') as f:
        for raw in f:
            line = raw.strip()
            if not line:
                continue
            parts = [p.strip() for p in line.split(sep)]
            if len(parts) == 1:
                # just a hash
                rows.append((None, parts[0]))
            else:
                # assume last field is the hash, first non-hash fields are "label"
                label = sep.join(parts[:-1])
                rows.append((label, parts[-1]))
    return rows

def main():
    p = argparse.ArgumentParser(description="Recover plaintext passwords from DES-ECB encrypted hashes (base64/hex). Input: plain text file.")
    p.add_argument('--key', default=DEFAULT_KEY, help='DES key (8 chars). Default: "12345678"')
    p.add_argument('--input', required=True, help='Input text file (one hash per line or "label,hash")')
    p.add_argument('--output', default='recovered.txt', help='Output text file (default: recovered.txt)')
    p.add_argument('--sep', default=',', help='Separator used in lines (default: ,)')
    args = p.parse_args()

    key = args.key
    try:
        ensure_key8(key)
    except Exception as e:
        print(f"[ERROR] Invalid key: {e}")
        return

    items = parse_plain_lines(args.input, sep=args.sep)
    with open(args.output, 'w', encoding='utf-8') as out:
        for label, h in items:
            try:
                dec = decrypt_password(h, key)
            except Exception as e:
                dec = f"<ERROR: {e}>"
            if label:
                out.write(f"{label}{args.sep}{h}{args.sep}{dec}\n")
            else:
                out.write(f"{h}{args.sep}{dec}\n")

    print(f"[OK] Wrote {len(items)} results to {args.output}")

if __name__ == '__main__':
    main()
